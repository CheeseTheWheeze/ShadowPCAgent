import argparse
import json
from pathlib import Path
from typing import Sequence

from shadowpcagent.config import load_config, merge_allowlist
from shadowpcagent.core import Orchestrator
from shadowpcagent.editor import EditRequest
from shadowpcagent.powershell import build_inventory_and_dedupe_script


def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        description="ShadowPCAgent prototype runner",
    )
    parser.add_argument(
        "task",
        nargs="?",
        default="Review repository and propose improvements",
        help="Task description for the agent to execute.",
    )
    parser.add_argument(
        "--task-file",
        default=None,
        help="Path to a file containing the task description.",
    )
    parser.add_argument(
        "--approve-sensitive",
        action="store_true",
        help="Allow the prototype to proceed with sensitive tasks.",
    )
    parser.add_argument(
        "--allow",
        action="append",
        default=[],
        help="Allowlist command (repeatable). Defaults to git, ls, pwd.",
    )
    parser.add_argument(
        "--root",
        default=".",
        help="Root directory to scan for the demo run.",
    )
    parser.add_argument(
        "--command",
        default="git status -sb",
        help="Allowlisted shell command to execute as part of the run.",
    )
    parser.add_argument(
        "--config",
        default=None,
        help="Path to a JSON config file.",
    )
    parser.add_argument(
        "--max-files",
        type=int,
        default=None,
        help="Maximum files to scan in the workspace.",
    )
    parser.add_argument(
        "--edit-file",
        default=None,
        help="Path to a file to edit (requires --find and --replace).",
    )
    parser.add_argument(
        "--find",
        default=None,
        help="Text to find in the target file.",
    )
    parser.add_argument(
        "--replace",
        default=None,
        help="Replacement text for the target file.",
    )
    parser.add_argument(
        "--apply",
        action="store_true",
        help="Apply the edit instead of drafting a diff only.",
    )
    parser.add_argument(
        "--log-dir",
        default=".shadowpcagent/logs",
        help="Directory for JSONL run logs.",
    )
    parser.add_argument(
        "--draft-note",
        default=None,
        help="Write a draft note patch (stored under .shadowpcagent/drafts).",
    )
    parser.add_argument(
        "--apply-draft",
        default=None,
        help="Apply a draft patch file generated by the agent.",
    )
    parser.add_argument(
        "--dry-run-apply",
        action="store_true",
        help="Validate a draft patch without applying it.",
    )
    parser.add_argument(
        "--plan-only",
        action="store_true",
        help="Generate a plan and summary without executing shell or GUI actions.",
    )
    parser.add_argument(
        "--json",
        action="store_true",
        help="Output a JSON summary.",
    )
    parser.add_argument(
        "--emit-powershell-cleanup-script",
        action="store_true",
        help="Print a PowerShell inventory/dedup script and exit.",
    )
    return parser


def main(argv: Sequence[str] | None = None) -> int:
    parser = build_parser()
    args = parser.parse_args(argv)

    if args.emit_powershell_cleanup_script:
        print(build_inventory_and_dedupe_script())
        return 0

    config = load_config(Path(args.config)) if args.config else load_config(None)
    if args.max_files is not None:
        config = config.__class__(
            allowlist=config.allowlist,
            max_files=args.max_files,
            log_dir=config.log_dir,
            draft_dir=config.draft_dir,
        )
    config = merge_allowlist(config, args.allow)
    orchestrator = Orchestrator(
        allowlist=config.allowlist,
        log_dir=Path(args.log_dir),
        draft_dir=config.draft_dir,
    )
    task = _load_task(args)
    summary = orchestrator.run(
        task=task,
        approve_sensitive=args.approve_sensitive,
        repo_root=Path(args.root),
        command=args.command,
        draft_note=args.draft_note,
        edit_request=_build_edit_request(args),
        max_files=config.max_files,
        plan_only=args.plan_only,
        apply_draft_path=Path(args.apply_draft) if args.apply_draft else None,
        dry_run_apply=args.dry_run_apply,
    )

    if summary.status == "approval_required":
        if args.json:
            payload = {
                "status": "approval_required",
                "reasons": summary.safety_report.reasons,
                "draft_diff": summary.safety_report.draft_diff,
                "files_scanned": summary.files_scanned,
                "file_types": summary.file_types,
                "log_path": summary.log_path,
                "draft_path": summary.draft_path,
                "edit_path": summary.edit_path,
                "edit_diff": summary.edit_diff,
                "plan_only": summary.plan_only,
                "applied_patch": summary.applied_patch.__dict__
                if summary.applied_patch
                else None,
                "applied_patch_path": summary.applied_patch_path,
                "run_summary_path": summary.run_summary_path,
                "run_history_path": summary.run_history_path,
            }
            print(json.dumps(payload, indent=2))
        else:
            print("Sensitive changes detected. Approval required.")
            for reason in summary.safety_report.reasons:
                print(f"- {reason}")
            print("\nDraft diff:")
            print(summary.safety_report.draft_diff)
        return 2

    if args.json:
        payload = {
            "status": summary.status,
            "reasons": summary.safety_report.reasons,
            "files_scanned": summary.files_scanned,
            "file_types": summary.file_types,
            "repo_root": summary.repo_root,
            "log_path": summary.log_path,
            "draft_path": summary.draft_path,
            "edit_path": summary.edit_path,
            "edit_diff": summary.edit_diff,
            "plan_only": summary.plan_only,
            "applied_patch": summary.applied_patch.__dict__
            if summary.applied_patch
            else None,
            "applied_patch_path": summary.applied_patch_path,
            "run_summary_path": summary.run_summary_path,
            "run_history_path": summary.run_history_path,
            "shell": {
                "command": summary.shell_result.command,
                "returncode": summary.shell_result.returncode,
                "stdout": summary.shell_result.stdout,
                "stderr": summary.shell_result.stderr,
            }
            if summary.shell_result
            else None,
            "actions": [action.__dict__ for action in summary.actions],
        }
        print(json.dumps(payload, indent=2))
    else:
        print("Task executed in prototype mode.")
        print(f"Scanned {summary.files_scanned} files in {summary.repo_root}.")
        if summary.shell_result:
            print(f"Command output:\n{summary.shell_result.stdout}")
    return 0


def _build_edit_request(args: argparse.Namespace) -> EditRequest | None:
    if args.edit_file is None:
        return None
    if args.find is None or args.replace is None:
        raise ValueError("--edit-file requires --find and --replace.")
    return EditRequest(
        path=Path(args.edit_file),
        find_text=args.find,
        replace_text=args.replace,
        apply=args.apply,
    )


def _load_task(args: argparse.Namespace) -> str:
    if args.task_file is None:
        return args.task
    task_path = Path(args.task_file)
    return task_path.read_text(encoding="utf-8").strip()


if __name__ == "__main__":
    raise SystemExit(main())
